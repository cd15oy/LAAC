"""
Landscape Aware Algorithm Configurator
Copyright (C) 2021 Cody Dennis

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

""" 
Responsible for producing a feature vector from a sequence of solutions.
"""

from ctypes import POINTER, byref, c_long, cdll,c_double,c_int,c_long, pointer
import numpy as np 
from random import Random

class CharacterizerError(Exception):
    pass

class Characterizer:
    def __init__(self, seed):
        self.characterizer = cdll.LoadLibrary('FLA/Characterize.so')
        self.rng = Random(seed)

    #Result should contain the following 
    #A field "solutions" which is a list of dicts representing the solution generated by each iteration of the algorithm. These dicts contain fields "quality" and "solution" 
    #A field "state" which is a list of lists of dicts representing the considered potential solutions from each iteration. These dicts also contain fields "quality" and "state"
    def characterize(self, results:dict) -> np.ndarray:
        
        numSolutions = len(results["solutions"])
        if numSolutions <= 0:
            return np.array([]) 

        dims = len(results["solutions"][0]["solution"]) 

        seed = c_long(self.rng.randint(0,4000000000)) 

        SOLUTION = POINTER(c_double)

        solutions = (SOLUTION*numSolutions)() 
        quality = (c_double*numSolutions)()

        for i,sol in enumerate(results["solutions"]):
            solutions[i] =  SOLUTION() 
            solutions[i] = (c_double*dims)(*sol["solution"])
            print(solutions[i])
            quality[i] = sol["quality"] 
        
        
        state = (POINTER(SOLUTION)*numSolutions)()
        stateQuality = ((POINTER(c_double))*numSolutions)()
        stateSizes = (c_int*numSolutions)()

        for i,st in enumerate(results["state"]):
            state[i] = (SOLUTION*len(st))()
            stateQuality[i] = (c_double*len(st))()
            stateSizes[i] = len(st)
            for j in range(len(st)):
                state[i][j] = (c_double*dims)(*st[j]["solution"]) 
                stateQuality[i][j] = st[j]["quality"] 

        #TODO: the c++ code cannot initialize new datastructures and return 
        #we should construct a struct here in python, with the required memory already allocated, and pass that to c++ 
        #c++ then fills in the values for each FLM and we go brrrrr
        expectedLength = 104 

        characteristics = (c_double*expectedLength)()

        v = self.characterizer.characterize(solutions, quality, state, stateQuality, numSolutions, stateSizes, dims, byref(characteristics), seed)

        if v != expectedLength:
            raise CharacterizerError("Characterizer overran the characteristic array")

        print(v)
        print(characteristics)

        print([x for x in characteristics])

        #(double ** solutions, double * quality, double *** state, double ** stateQuality, int numSolutions, int * stateSize, int dims, double * characteristics, long seed)