"""
Landscape Aware Algorithm Configurator
Copyright (C) 2021 Cody Dennis

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

""" 
Responsible for producing a feature vector from a sequence of solutions.
"""

#TODO: it seems the c++ code does not always yield the same results for the same inputs 
#probably an error in Chcaracterize.cpp or an interfacing issue of some kind

from ctypes import POINTER, Structure, byref, c_long, cdll,c_double,c_int,c_long, pointer
import numpy as np 
from random import Random
from Configurator.RoC import fit 
import sys 

#A generic error 
class CharacterizerError(Exception):
    pass

#A struct for receiving results from the FLA library
class Characteristics(Structure):
    _fields_ = [
        ("FDC", c_double),
        ("yDist", c_double*2),
        ("pairwise", c_double*54),
        ("FEM", c_double),
        ("grad", c_double*7),
        ("M", c_double*2),
        ("stag", c_double*2),
        ("diversity", POINTER(c_double)),
        ("gBestStep", POINTER(c_double)),
        ("gBestStag", POINTER(c_double)),
        ("gBestyDist", POINTER(c_double))
    ]
    

class Characterizer:
    def __init__(self):
        self.characterizer = cdll.LoadLibrary('FLA/Characterize.so')

    #returns the size of feature vectors
    def featureSize(dimensionality:int) -> int:
        return 79 + (4*dimensionality)

    #Result should contain the following 
    #A field "solutions" which is a list of dicts representing the solution generated by each iteration of the algorithm. These dicts contain fields "quality" and "solution" 
    #A field "state" which is a list of lists of dicts representing the considered potential solutions from each iteration. These dicts also contain fields "quality" and "state"
    def characterize(self, results:dict, seed:int) -> np.ndarray:



        #We need to construct the args for the c function
        
        numSolutions = len(results["solutions"])
        if numSolutions <= 0:
            return np.array([]) 

        dims = len(results["solutions"][0]["solution"]) 

        seed = c_long(seed) 

        SOLUTION = POINTER(c_double)

        solutions = (SOLUTION*numSolutions)() 
        quality = (c_double*numSolutions)()

        for i,sol in enumerate(results["solutions"]):
            solutions[i] =  SOLUTION() 
            solutions[i] = (c_double*dims)(*sol["solution"])
            quality[i] = sol["quality"] 
        
        numStates = len(results["state"])
        state = (POINTER(SOLUTION)*numStates)()
        stateQuality = ((POINTER(c_double))*numStates)()
        stateSizes = (c_int*numStates)()

        for i,st in enumerate(results["state"]):
            state[i] = (SOLUTION*len(st))()
            stateQuality[i] = (c_double*len(st))()
            stateSizes[i] = len(st)
            for j in range(len(st)):
                state[i][j] = (c_double*dims)(*st[j]["solution"]) 
                stateQuality[i][j] = st[j]["quality"] 

        if numStates != numSolutions:
            print("The number of states received by characterizer does not match the number of solution. Are you sure this is what you want?", file=sys.stderr)

        characteristics = Characteristics()
        characteristics.diversity = (c_double*numSolutions)() 
        characteristics.gBestStep = (c_double*numSolutions)()
        characteristics.gBestStag = (c_double*(dims*2))()
        characteristics.gBestyDist = (c_double*(dims*2))()

        try:
            self.characterizer.characterize(solutions, quality, state, stateQuality, numSolutions, stateSizes, dims, byref(characteristics), seed)

            # print(characteristics.FDC)
            # print([x for x in characteristics.yDist])
            # print([x for x in characteristics.pairwise])
            # print(characteristics.FEM)
            # print([x for x in characteristics.grad])
            # print([x for x in characteristics.M])
            # print([x for x in characteristics.stag])
            # print([characteristics.diversity[x] for x in range(numSolutions)])
            # print([characteristics.gBestStep[x] for x in range(numSolutions)])
            # print([characteristics.gBestStag[x] for x in range(2*dims)])
            # print([characteristics.gBestyDist[x] for x in range(2*dims)])
            
            #if you run python3 Configure.py -scenario optFiles/scenario.json -seed 12345 then characteristics.gBestStep contains a non-finite value 
            #TODO ^^ figure it out

            #Construct a feature vector with the results 
            out =   [[characteristics.FDC] + 
                    [x for x in characteristics.yDist] + 
                    [x for x in characteristics.pairwise] + 
                    [characteristics.FEM] +
                    [x for x in characteristics.grad] +
                    [x for x in characteristics.M] + 
                    [x for x in characteristics.stag] +
                    [characteristics.diversity[-1]] + 
                    fit([characteristics.diversity[x] for x in range(numSolutions)]) + 
                    [characteristics.gBestStep[-1]] + 
                    fit([characteristics.gBestStep[x] for x in range(numSolutions)]) +
                    [characteristics.gBestStag[x] for x in range(2*dims)] +
                    [characteristics.gBestyDist[x] for x in range(2*dims)]
            ]

            out = np.asarray(out[0])

            return out 

        except:
            raise CharacterizerError("An error occurred during characterization")


